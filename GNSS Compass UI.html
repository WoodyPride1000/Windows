<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GNSS Compass UI</title>
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet" />
    <!-- Tailwind CSS with JIT compiler -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --primary-color: #3b82f6;
            --secondary-color: #e5e7eb;
            --text-color: #1f2937;
            --bg-color: #f3f4f6;
            --card-bg: #ffffff;
        }

        body {
            margin: 0; /* Added margin: 0 */
            font-family: 'Inter', sans-serif; /* Kept Inter font, added sans-serif fallback */
            color: var(--text-color);
            background-color: var(--bg-color);
        }

        /* Set a fixed height for the map container */
        #map {
            width: 100%; /* Ensure full width */
            height: 60vh; /* Changed to 60vh for better mobile viewing */
        }

        /* Style for the active tab */
        .tab.active {
            background-color: var(--primary-color) !important;
            color: white !important;
        }

        /* Custom message box for alerts */
        #messageBox {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #messageBox.show {
            opacity: 1;
        }

        /* Apply 60vh height to the chart canvas as well for consistency */
        #headingChart {
            height: 60vh;
        }
    </style>
    <!-- Leaflet JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Chart.js for the heading distribution graph -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- Socket.io is included in the original HTML, so we'll keep the link. -->
    <!-- We'll simulate its behavior in the JS below. -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 transition-colors duration-300">
    <!-- Message Box for non-alert notifications -->
    <div id="messageBox" class="hidden"></div>
    
    <div class="max-w-screen-xl mx-auto p-4 md:p-6 lg:p-8">
        <!-- Tabs -->
        <div class="tabs flex space-x-2 md:space-x-4 mb-4">
            <button id="tabMap" class="tab active bg-blue-500 text-white px-4 py-2 rounded-lg font-semibold shadow-md transition-colors duration-200 hover:bg-blue-600">
                åœ°å›³
            </button>
            <button id="tabControl" class="tab bg-gray-200 text-gray-800 px-4 py-2 rounded-lg font-semibold shadow-md transition-colors duration-200 hover:bg-gray-300">
                åˆ¶å¾¡
            </button>
        </div>

        <!-- Tab Content Panels -->
        <div id="tabContent" class="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-lg transition-colors duration-300">
            <!-- Map Panel -->
            <div id="mapPanel" class="block">
                <div id="map" class="w-full rounded-xl shadow-inner mb-4"></div>
                
                <!-- Information and Control Panel -->
                <div id="infoPanel" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm bg-gray-50 dark:bg-gray-700 p-4 rounded-lg shadow-sm">
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="ç¾åœ¨åœ°" data-label-en="Position" class="font-bold">ç¾åœ¨åœ° (Lat/Lng)</span>: 
                        <span id="latlng" class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="UTM" data-label-en="UTM" class="font-bold">UTM</span>: 
                        <span id="utm" class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="æ–¹ä½è§’" data-label-en="Heading" class="font-bold">æ–¹ä½è§’</span>: 
                        <span id="heading" class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="GPSçŠ¶æ…‹" data-label-en="GPS Status" class="font-bold">GPSçŠ¶æ…‹</span>: 
                        <span id="gpsStatus" class="font-mono text-green-500 font-semibold">--</span>
                    </div>
                    <!-- New container for multiple symbol info -->
                    <div id="symbolInfoContainer" class="col-span-full grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2">
                        <!-- Symbol info will be dynamically inserted here -->
                        <div class="flex items-center space-x-2">
                            <span data-label-ja="ã‚·ãƒ³ãƒœãƒ«è·é›¢" data-label-en="Symbol Distance" class="font-bold">ã‚·ãƒ³ãƒœãƒ«è·é›¢</span>: 
                            <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span data-label-ja="ä»°ä¿¯è§’" data-label-en="Elevation Angle" class="font-bold">ä»°ä¿¯è§’</span>: 
                            <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span data-label-ja="è‡ªç”±ç©ºé–“æå¤±" data-label-en="FSPL" class="font-bold">è‡ªç”±ç©ºé–“æå¤±</span>: 
                            <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="flex items-center space-x-1 cursor-pointer">
                            <input type="checkbox" id="useOfflineTiles" class="form-checkbox h-4 w-4 text-blue-600 rounded">
                            <span class="text-gray-700 dark:text-gray-200">ã‚¿ã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥</span>
                        </label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label for="sectorAngle" class="text-gray-700 dark:text-gray-200">
                            <span data-label-ja="æ‰‡å½¢è§’åº¦" data-label-en="Sector Angle">æ‰‡å½¢è§’åº¦</span>: 
                            <span id="angleVal" class="font-mono text-blue-600">30</span>Â°
                        </label>
                        <input type="range" id="sectorAngle" min="10" max="180" value="30" oninput="document.getElementById('angleVal').textContent = this.value">
                    </div>
                    <div class="flex items-center space-x-2">
                        <label for="frequencyInput" class="text-gray-700 dark:text-gray-200">
                            <span data-label-ja="å‘¨æ³¢æ•°" data-label-en="Frequency">å‘¨æ³¢æ•°</span>: 
                        </label>
                        <input type="number" id="frequencyInput" value="300" min="1" class="w-24 px-2 py-1 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <span class="text-gray-700 dark:text-gray-200">MHz</span>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-2 mt-4">
                    <button id="toggleFollow" class="bg-gray-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors duration-200">
                        è¿½å¾“: OFF
                    </button>
                    <button id="toggleLang" class="bg-gray-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors duration-200">
                        ğŸŒ è¨€èª
                    </button>
                    <button id="toggleSim" class="bg-yellow-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-yellow-500 transition-colors duration-200">
                        ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼èµ·å‹•
                    </button>
                    <button id="centerMap" class="bg-green-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-green-500 transition-colors duration-200">
                        è‡ªå·±ä½ç½®ã«ç§»å‹•
                    </button>
                    <button id="downloadLog" class="bg-blue-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-blue-500 transition-colors duration-200">
                        ãƒ­ã‚°ä¿å­˜
                    </button>
                    <button id="clearRoute" class="bg-red-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-red-500 transition-colors duration-200">
                        ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢
                    </button>
                    <button id="toggleDebug" class="bg-purple-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-purple-500 transition-colors duration-200">
                        Debug: ON
                    </button>
                    <label for="csvUpload" class="bg-indigo-400 px-3 py-2 rounded-lg text-sm font-medium cursor-pointer text-center hover:bg-indigo-500 transition-colors duration-200">
                        CSVå†ç”Ÿ
                    </label>
                    <input type="file" id="csvUpload" accept=".csv" class="hidden">
                    <button id="servoBtn" class="bg-orange-400 px-3 py-2 rounded-lg text-sm font-medium hover:bg-orange-500 transition-colors duration-200">
                        ã‚µãƒ¼ãƒœåˆ¶å¾¡ï¼ˆä»®æƒ³ï¼‰
                    </button>
                    <button id="clearCacheBtn" class="bg-red-200 px-3 py-2 rounded-lg text-sm font-medium hover:bg-red-300 transition-colors duration-200">
                        ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
                    </button>
                    <button id="clearSymbolBtn" class="bg-pink-300 px-3 py-2 rounded-lg text-sm font-medium hover:bg-pink-400 transition-colors duration-200">
                        ã‚·ãƒ³ãƒœãƒ«ã‚¯ãƒªã‚¢
                    </button>
                </div>
            </div>

            <!-- Control Panel -->
            <div id="controlPanel" class="hidden">
                <h2 class="text-xl font-bold mb-4 text-gray-800 dark:text-white">åˆ¶å¾¡ãƒ»ã‚°ãƒ©ãƒ•</h2>
                <div class="text-gray-600 dark:text-gray-300">
                    <p>ã“ã®ãƒ‘ãƒãƒ«ã§ã¯ã€ãƒ‡ãƒã‚¤ã‚¹ã®åˆ¶å¾¡ã‚„ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ã‚°ãƒ©ãƒ•è¡¨ç¤ºã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li><b>é€Ÿåº¦åˆ¶å¾¡:</b> ãƒ‡ãƒã‚¤ã‚¹ã®ç§»å‹•é€Ÿåº¦ã‚’èª¿æ•´ã€‚</li>
                        <li><b>è§’åº¦åˆ¶å¾¡:</b> æ–¹å‘ã‚’èª¿æ•´ã€‚</li>
                        <li><b>ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ•:</b> æ–¹ä½è§’ã‚„GPSç²¾åº¦ãªã©ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’å¯è¦–åŒ–ã€‚</li>
                        <li><b>ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼:</b> `HeadingSectorLayer`ã¨ã„ã†ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</li>
                    </ul>
                </div>
                <div class="mt-8">
                    <h3 class="text-lg font-semibold mb-2 text-gray-800 dark:text-white">æ–¹ä½è§’ã®åˆ†å¸ƒ</h3>
                    <div class="w-full h-80">
                        <canvas id="headingChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
    console.log("Script execution started."); // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œé–‹å§‹ã‚’ãƒ­ã‚°
    // Global error handler for debugging
    window.onerror = function(message, source, lineno, colno, error) {
        console.error("Global Error Caught:", {
            message: message,
            source: source,
            lineno: lineno,
            colno: colno,
            error: error ? error.stack : "No stack trace"
        });
        // Optionally, display a message to the user
        // showMessage("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + message, 5000);
        return true; // Prevent default error handling
    };

    // --- UTILITIES ---
    // A simplified, self-contained UTM conversion function. For production, a robust library is recommended.
    // This is for demonstration purposes.
    function latLngToUtm(lat, lng) {
        // Simplified conversion for demonstration
        const zone = Math.floor((lng + 180) / 6) + 1;
        const letter = "CDEFGHJKLMNPQRSTUVWXX"[Math.floor((lat + 80) / 8)];
        const utm_x = 500000 + (lng - (zone * 6 - 183)) * 111320;
        const utm_y = lat > 0 ? lat * 111132.954 : lat * 110574.389;
        return `${zone}${letter} ${utm_x.toFixed(2)} ${utm_y.toFixed(2)}`;
    }

    // --- GEOSPATIAL CALCULATIONS ---
    // Haversine formula to calculate distance between two LatLng points on a sphere.
    // Returns distance in meters.
    function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // metres (Earth's mean radius)
        const Ï†1 = lat1 * Math.PI / 180; // Ï†, Î» in radians
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // in meters
    }

    // Calculates elevation angle between two points given their LatLng and Altitude
    // Returns angle in degrees
    function calculateElevationAngle(lat1, lon1, alt1, lat2, lon2, alt2) {
        console.log("--- Elevation Angle Calculation ---");
        console.log(`Point 1: Lat=${lat1}, Lon=${lon1}, Alt=${alt1}`);
        console.log(`Point 2: Lat=${lat2}, Lon=${lon2}, Alt=${alt2}`);

        const R_EARTH = 6371e3; // Earth's mean radius in meters

        const horizontalDistance = calculateHaversineDistance(lat1, lon1, lat2, lon2);
        let verticalDistance = alt2 - alt1;

        // --- Curvature Correction ---
        // The effect of Earth's curvature causes the horizon to "drop" relative to a flat plane.
        // For a line of sight from point 1 to point 2, if point 2 is further away,
        // its effective altitude relative to a tangent plane at point 1 will be lower due to curvature.
        // The correction is approximately d^2 / (2 * R_EARTH)
        const curvatureCorrection = (horizontalDistance * horizontalDistance) / (2 * R_EARTH);
        verticalDistance -= curvatureCorrection; // Subtract the drop due to curvature from the vertical distance

        console.log(`Horizontal Distance: ${horizontalDistance.toFixed(2)} m`);
        console.log(`Initial Vertical Distance: ${(alt2 - alt1).toFixed(2)} m`);
        console.log(`Curvature Correction: ${curvatureCorrection.toFixed(2)} m`);
        console.log(`Corrected Vertical Distance: ${verticalDistance.toFixed(2)} m`);

        if (horizontalDistance === 0) {
            console.log("Horizontal distance is zero.");
            return verticalDistance > 0 ? 90 : (verticalDistance < 0 ? -90 : 0);
        }

        const angleRad = Math.atan2(verticalDistance, horizontalDistance);
        const angleDeg = angleRad * 180 / Math.PI;
        console.log(`Calculated Elevation Angle (with curvature): ${angleDeg.toFixed(2)} Â°`);
        console.log("---------------------------------");
        return angleDeg; // Convert to degrees
    }

    // Calculates the bearing (azimuth) from point 1 to point 2
    // Returns bearing in degrees (0-360, 0=North, clockwise)
    function calculateBearing(lat1, lon1, lat2, lon2) {
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;

        const y = Math.sin(Î”Î») * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                  Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
        let bearingRad = Math.atan2(y, x);
        
        // Convert to degrees and normalize to 0-360
        let bearingDeg = (bearingRad * 180 / Math.PI + 360) % 360;
        return bearingDeg;
    }

    // Calculates Free Space Path Loss (FSPL) in dB
    // d is distance in meters, freqMHz is frequency in MHz
    function calculateFreeSpacePathLoss(d, freqMHz) {
        if (d <= 0 || freqMHz <= 0) {
            return NaN; // Invalid input
        }
        // FSPL (dB) = 20 log10(d_km) + 20 log10(f_MHz) + 32.44
        // Convert distance from meters to kilometers
        const d_km = d / 1000;
        const fspl = 20 * Math.log10(d_km) + 20 * Math.log10(freqMHz) + 32.44;
        return fspl;
    }


    // --- CUSTOM LEAFLET TILE LAYER WITH CACHING ---
    L.TileLayer.Cache = L.TileLayer.extend({
        initialize: function (url, options) {
            L.TileLayer.prototype.initialize.call(this, url, options);
            this.cacheKey = options.cacheKey || 'leaflet-tile-cache';
            this.useCache = options.useCache || false;
        },

        createTile: function (coords, done) {
            const tile = document.createElement('img');
            L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
            L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));

            const tileUrl = this.getTileUrl(coords);
            const cacheId = `${this.cacheKey}-${coords.z}-${coords.x}-${coords.y}`;

            if (this.useCache) {
                const cachedTile = localStorage.getItem(cacheId);
                if (cachedTile) {
                    tile.src = cachedTile;
                    return tile;
                }
            }

            // If not cached or caching is off, fetch from network
            tile.src = tileUrl;

            if (this.useCache) {
                // Save to cache after loading. Use a small timeout to ensure image is fully rendered.
                tile.onload = () => {
                    setTimeout(() => { // Small delay to ensure image is drawn to canvas
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = tile.naturalWidth;
                            canvas.height = tile.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(tile, 0, 0);
                            localStorage.setItem(cacheId, canvas.toDataURL());
                        } catch (e) {
                            console.warn('Failed to cache tile (likely storage full):', e);
                            // In a real application, you might implement a cache eviction strategy here.
                        }
                    }, 10); // Short delay
                };
            }
            return tile;
        }
    });

    L.tileLayer.cache = function (url, options) {
        return new L.TileLayer.Cache(url, options);
    };

    // --- MAIN APPLICATION LOGIC ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded fired."); // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç”Ÿã‚’ãƒ­ã‚°

        // --- CONSTANTS AND STATE ---
        const mapPanel = document.getElementById('mapPanel');
        const controlPanel = document.getElementById('controlPanel');
        const tabMap = document.getElementById('tabMap');
        const tabControl = document.getElementById('tabControl');
        
        const latlngSpan = document.getElementById('latlng');
        const utmSpan = document.getElementById('utm');
        const headingSpan = document.getElementById('heading');
        const gpsStatusSpan = document.getElementById('gpsStatus');
        const sectorAngleInput = document.getElementById('sectorAngle');
        const angleValSpan = document.getElementById('angleVal');
        const symbolInfoContainer = document.getElementById('symbolInfoContainer'); // Get the new container
        const frequencyInput = document.getElementById('frequencyInput'); // New: Frequency input

        const toggleLangBtn = document.getElementById('toggleLang');
        const toggleSimBtn = document.getElementById('toggleSim');
        const centerMapBtn = document.getElementById('centerMap');
        const clearRouteBtn = document.getElementById('clearRoute');
        const downloadLogBtn = document.getElementById('downloadLog');
        const csvUploadInput = document.getElementById('csvUpload');
        const toggleDebugBtn = document.getElementById('toggleDebug');
        const servoBtn = document.getElementById('servoBtn');
        const messageBox = document.getElementById('messageBox');
        const toggleFollowBtn = document.getElementById('toggleFollow');
        const useOfflineTilesCheckbox = document.getElementById('useOfflineTiles');
        const clearCacheBtn = document.getElementById('clearCacheBtn');
        const clearSymbolBtn = document.getElementById('clearSymbolBtn'); // New

        let isJapanese = true;
        let isSimulating = false;
        let isDebugging = false;
        let isFollowing = false;
        let simulationInterval = null;
        // currentPosition now includes altitude for elevation angle calculation
        let currentPosition = [35.681236, 139.767125, 100]; // Default starting position (Tokyo, altitude 100m)
        let currentHeading = 0;
        let logData = [];
        let routeCoordinates = [];
        // symbolMarkers now stores objects: { marker: L.Marker, latLngAlt: [lat, lng, alt] }
        let symbolMarkers = []; 
        let lastKnownLatLng = [currentPosition[0], currentPosition[1]]; // Store initial LatLng for optimization

        // Chart-related variables
        let headingHistory = [];
        let headingChart = null;

        // --- MAP SETUP ---
        let map = L.map('map').setView([currentPosition[0], currentPosition[1]], 16);
        let osmLayer; // Declare here to be accessible globally in this scope

        // Function to set or swap the tile layer based on caching preference
        function setTileLayer(useCache) {
            if (osmLayer) {
                map.removeLayer(osmLayer);
            }
            osmLayer = L.tileLayer.cache('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                cacheKey: 'osm-tiles', // Unique key for this tile set in localStorage
                useCache: useCache
            }).addTo(map);
        }

        const gpsMarker = L.marker([currentPosition[0], currentPosition[1]]).addTo(map);
        const routePolyline = L.polyline(routeCoordinates, { color: 'blue' }).addTo(map);

        // A custom canvas layer to draw the heading line and sector
        const HeadingSectorLayer = L.Layer.extend({
            onAdd: function (map) {
                this._map = map;
                // Create a canvas element and append it to the `overlayPane`
                this._el = L.DomUtil.create('canvas', 'leaflet-zoom-animated'); // Keep leaflet-zoom-animated for initial positioning
                
                // Set initial size of the canvas
                const size = map.getSize();
                this._el.width = size.x;
                this._el.height = size.y;
                
                // Append canvas to the map's overlay pane to ensure it's on top of tiles
                this._map.getPane('overlayPane').appendChild(this._el);
                this._ctx = this._el.getContext('2d');
                
                // Add event listeners for redrawing on map changes
                this._map.on('moveend', this.redraw, this);
                this._map.on('resize', this.redraw, this);
                this._map.on('zoomend', this.redraw, this); // Add zoomend listener
                this._map.on('viewreset', this.redraw, this); // Add viewreset listener as well, for good measure
                
                // Initial draw
                this.redraw();
            },

            onRemove: function (map) {
                // Remove the canvas element and event listeners
                this._map.getPane('overlayPane').removeChild(this._el);
                this._map.off('moveend', this.redraw, this);
                this._map.off('resize', this.redraw, this);
                this._map.off('zoomend', this.redraw, this); // Remove zoomend listener
                this._map.off('viewreset', this.redraw, this); // Remove viewreset listener
            },
            
            // Public method to trigger a redraw
            redraw: function () { 
                console.log("HeadingSectorLayer.redraw called."); // Debugging log
                console.log("Inside redraw - currentPosition:", currentPosition); // ãƒ­ã‚°ã‚’è¿½åŠ 
                console.log("Inside redraw - currentHeading:", currentHeading); // ãƒ­ã‚°ã‚’è¿½åŠ 
                console.log("Inside redraw - symbolMarkers:", symbolMarkers); // ãƒ­ã‚°ã‚’è¿½åŠ 

                const map = this._map;
                if (!map || !gpsMarker || !this._el || !this._ctx) { 
                    console.warn("HeadingSectorLayer.redraw: Missing map, gpsMarker, canvas element, or context. Skipping redraw.");
                    return;
                }
                
                try { 
                    const size = map.getSize();
                    // Get the top-left pixel coordinates of the map pane
                    const topLeft = map.containerPointToLayerPoint([0, 0]);

                    // Set canvas size
                    if (this._el.width !== size.x || this._el.height !== size.y) {
                        this._el.width = size.x;
                        this._el.height = size.y;
                        console.log(`Canvas resized to: ${size.x}x${size.y}`); // Log canvas resize
                    }

                    const ctx = this._ctx;
                    // Reset the context's transformation matrix to the identity matrix
                    // This is crucial to prevent accumulated transformations from previous redraws
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    
                    ctx.clearRect(0, 0, this._el.width, this._el.height);
                    console.log("Canvas cleared.");

                    // Position the canvas element correctly relative to the map pane
                    L.DomUtil.setPosition(this._el, topLeft);
                    console.log(`Canvas positioned at: [${topLeft.x}, ${topLeft.y}]`);

                    // Translate the context to account for the canvas's position relative to the map's origin
                    // This ensures that latLngToLayerPoint coordinates (which are relative to map origin)
                    // can be directly used for drawing on the canvas.
                    ctx.translate(-topLeft.x, -topLeft.y);
                    console.log(`Context translated by: [${-topLeft.x}, ${-topLeft.y}]`);
                    
                    // Get the center point from the marker's position
                    // Use map.latLngToLayerPoint which accounts for current zoom and pan
                    const centerLatLng = gpsMarker.getLatLng();
                    const centerPoint = map.latLngToLayerPoint(centerLatLng);
                    console.log(`GPS Marker LatLng: [${centerLatLng.lat}, ${centerLatLng.lng}]`); // Log marker LatLng
                    console.log(`Center Point (Layer): [${centerPoint.x}, ${centerPoint.y}]`); // Log center point

                    // Calculate dynamic radii based on map height
                    const mapHeight = map.getSize().y;
                    const lineRadius = mapHeight * 0.4;
                    const sectorRadius = mapHeight * 0.3;
                    console.log(`Line Radius: ${lineRadius}, Sector Radius: ${sectorRadius}`); // Log radii

                    // Draw the heading line
                    if (currentHeading !== null) {
                        const lineAngle = (currentHeading - 90) * (Math.PI / 180);
                        const endPointX = centerPoint.x + lineRadius * Math.cos(lineAngle);
                        const endPointY = centerPoint.y + lineRadius * Math.sin(lineAngle);
                        ctx.beginPath();
                        ctx.moveTo(centerPoint.x, centerPoint.y);
                        ctx.lineTo(endPointX, endPointY);
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        console.log(`Heading Line drawn from [${centerPoint.x}, ${centerPoint.y}] to [${endPointX}, ${endPointY}] with heading ${currentHeading}Â°`); // Log heading line
                    }

                    // Draw the sector
                    if (currentHeading !== null) {
                        const angle = parseInt(sectorAngleInput.value);
                        // Convert currentHeading (compass 0=North, clockwise) to Canvas angle (0=East, clockwise)
                        const canvasHeading = (currentHeading - 90 + 360) % 360; // Ensure positive angle
                        
                        const startAngleDegrees = (canvasHeading - angle / 2 + 360) % 360;
                        const endAngleDegrees = (canvasHeading + angle / 2 + 360) % 360;

                        // Convert to radians for Canvas arc function
                        const startAngleRad = startAngleDegrees * (Math.PI / 180);
                        const endAngleRad = endAngleDegrees * (Math.PI / 180);

                        ctx.beginPath();
                        ctx.moveTo(centerPoint.x, centerPoint.y);
                        ctx.arc(centerPoint.x, centerPoint.y, sectorRadius, startAngleRad, endAngleRad, false);
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                        ctx.fill();
                        console.log(`Sector drawn with heading ${currentHeading}Â°, angle ${angle}Â° from ${startAngleDegrees}Â° to ${endAngleDegrees}Â°`); // Log sector
                    }

                    // Draw lines to symbols
                    symbolMarkers.forEach((symbolObj, idx) => {
                        const { marker, latLngAlt } = symbolObj;
                        const [sLat, sLng, sAlt] = latLngAlt;
                        const symbolPoint = map.latLngToLayerPoint(marker.getLatLng());
                        
                        const bearingToSymbol = calculateBearing(currentPosition[0], currentPosition[1], sLat, sLng);
                        let bearingDiff = Math.abs(currentHeading - bearingToSymbol);
                        if (bearingDiff > 180) {
                            bearingDiff = 360 - bearingDiff;
                        }

                        ctx.beginPath();
                        ctx.moveTo(centerPoint.x, centerPoint.y);
                        ctx.lineTo(symbolPoint.x, symbolPoint.y);

                        if (bearingDiff <= 10) {
                            ctx.strokeStyle = 'blue';
                            ctx.setLineDash([]);
                        } else {
                            ctx.strokeStyle = 'black';
                            ctx.setLineDash([5, 5]);
                        }
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        console.log(`Line to Symbol ${idx + 1} drawn from [${centerPoint.x}, ${centerPoint.y}] to [${symbolPoint.x}, ${symbolPoint.y}]`); // Log symbol line
                    });
                    ctx.setLineDash([]);
                } catch (e) {
                    console.error("Error drawing HeadingSectorLayer:", e);
                }
            }
        });
        
        // Add the custom layer to the map
        const headingSectorLayer = new HeadingSectorLayer().addTo(map);
        console.log("headingSectorLayer after creation:", headingSectorLayer); // Debugging line
        console.log("Initial state before first redraw:", { // ãƒ­ã‚°ã‚’è¿½åŠ 
            currentPosition: currentPosition,
            currentHeading: currentHeading,
            symbolMarkers: symbolMarkers
        });

        // --- CHART FUNCTIONS ---
        function initHeadingChart() {
            const ctx = document.getElementById('headingChart').getContext('2d');
            const data = {
                labels: Array.from({ length: 36 }, (_, i) => `${i * 10}Â°`),
                datasets: [{
                    label: isJapanese ? 'æ–¹ä½è§’ã®åˆ†å¸ƒ' : 'Heading Distribution',
                    data: new Array(36).fill(0),
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
                        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)',
                        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
                        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)',
                        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
                        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)',
                        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
                        'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)',
                        'rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)',
                    ]
                }]
            };
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    r: {
                        angleLines: {
                            display: true
                        },
                        suggestedMin: 0,
                        ticks: {
                            backdropColor: 'transparent',
                            showLabelBackdrop: false
                        }
                    }
                }
            };
            headingChart = new Chart(ctx, {
                type: 'polarArea',
                data: data,
                options: options
            });
        }

        function updateHeadingChart(newHeading) {
            headingHistory.push(newHeading);

            // Create bins for the polar area chart (0-360 degrees, 10-degree segments)
            const bins = new Array(36).fill(0);
            headingHistory.forEach(hdg => {
                const binIndex = Math.floor(hdg / 10);
                if (binIndex >= 0 && binIndex < 36) {
                    bins[binIndex]++;
                }
            });
            
            // Update the chart dataset
            if (headingChart) {
                headingChart.data.datasets[0].data = bins;
                headingChart.update();
            }
        }

        // --- Function to update symbol information in the UI ---
        function updateSymbolInfoUI() {
            symbolInfoContainer.innerHTML = ''; // Clear previous info

            if (symbolMarkers.length === 0) {
                // Display default placeholder if no symbols
                symbolInfoContainer.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="ã‚·ãƒ³ãƒœãƒ«è·é›¢" data-label-en="Symbol Distance" class="font-bold">ã‚·ãƒ³ãƒœãƒ«è·é›¢</span>: 
                        <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="ä»°ä¿¯è§’" data-label-en="Elevation Angle" class="font-bold">ä»°ä¿¯è§’</span>: 
                        <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span data-label-ja="è‡ªç”±ç©ºé–“æå¤±" data-label-en="FSPL" class="font-bold">è‡ªç”±ç©ºé–“æå¤±</span>: 
                        <span class="font-mono text-gray-600 dark:text-gray-300">--</span>
                    </div>
                `;
                return;
            }

            const currentFreqMHz = parseFloat(frequencyInput.value);
            if (isNaN(currentFreqMHz) || currentFreqMHz <= 0) {
                showMessage(isJapanese ? "æœ‰åŠ¹ãªå‘¨æ³¢æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚" : "Please enter a valid frequency.", 3000);
                // Fallback to a default value or prevent FSPL calculation
                // For now, we'll just not display FSPL if frequency is invalid.
            }


            symbolMarkers.forEach((symbolObj, index) => {
                const { latLngAlt } = symbolObj;
                const [sLat, sLng, sAlt] = latLngAlt;

                const dist = calculateHaversineDistance(currentPosition[0], currentPosition[1], sLat, sLng);
                const elevAngle = calculateElevationAngle(currentPosition[0], currentPosition[1], currentPosition[2], sLat, sLng, sAlt);
                const bearingDeg = calculateBearing(currentPosition[0], currentPosition[1], sLat, sLng);
                const bearingRad = bearingDeg * Math.PI / 180;
                const bearingMil = bearingDeg * (6400 / 360); // 1 degree = 6400 mils / 360 degrees
                
                let fsplText = '--';
                if (!isNaN(currentFreqMHz) && currentFreqMHz > 0) {
                    const fspl = calculateFreeSpacePathLoss(dist, currentFreqMHz);
                    fsplText = `${fspl.toFixed(2)} dB`;
                }

                const symbolDiv = document.createElement('div');
                symbolDiv.className = 'col-span-1 flex flex-col space-y-1 p-2 bg-gray-100 dark:bg-gray-600 rounded-md shadow-sm';
                symbolDiv.innerHTML = `
                    <span class="font-bold text-blue-700 dark:text-blue-300">ã‚·ãƒ³ãƒœãƒ« ${index + 1}</span>
                    <div class="flex items-center space-x-2 text-xs">
                        <span class="font-bold">è·é›¢</span>: 
                        <span class="font-mono text-gray-700 dark:text-gray-200">${dist.toFixed(2)} m</span>
                    </div>
                    <div class="flex items-center space-x-2 text-xs">
                        <span class="font-bold">ä»°ä¿¯è§’</span>: 
                        <span class="font-mono text-gray-700 dark:text-gray-200">${elevAngle.toFixed(2)} Â°</span>
                    </div>
                    <div class="flex items-center space-x-2 text-xs">
                        <span class="font-bold">æ–¹ä½è§’</span>: 
                        <span class="font-mono text-gray-700 dark:text-gray-200">${bearingDeg.toFixed(2)}Â° / ${bearingRad.toFixed(2)} rad / ${bearingMil.toFixed(2)} mil</span>
                    </div>
                    <div class="flex items-center space-x-2 text-xs">
                        <span class="font-bold">è‡ªç”±ç©ºé–“æå¤±</span>: 
                        <span class="font-mono text-gray-700 dark:text-gray-200">${fsplText}</span>
                    </div>
                `;
                symbolInfoContainer.appendChild(symbolDiv);
            });
        }
        
        // --- UTILITY FUNCTIONS ---
        // updateAllUI now accepts altitude for current position
        function updateAllUI(lat, lng, heading, alt = currentPosition[2]) { // Default to current altitude if not provided
            const utm = latLngToUtm(lat, lng);
            const latLngFormatted = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            const headingFormatted = `${heading.toFixed(2)}Â°`;

            latlngSpan.textContent = latLngFormatted;
            utmSpan.textContent = utm;
            headingSpan.textContent = headingFormatted;
            
            // Update map elements only if LatLng has changed
            const newLatLng = L.latLng(lat, lng);
            if (lat !== lastKnownLatLng[0] || lng !== lastKnownLatLng[1]) {
                gpsMarker.setLatLng(newLatLng);
                routeCoordinates.push(newLatLng);
                routePolyline.setLatLngs(routeCoordinates);
                lastKnownLatLng = [lat, lng]; // Update lastKnownLatLng
            }
            
            // Update currentPosition with new altitude
            currentPosition = [lat, lng, alt];

            // Calculate and display distance and elevation angle for all symbols
            updateSymbolInfoUI(); // Call the new function

            // Conditionally recenter the map if following is enabled
            if (isFollowing) {
                map.setView(newLatLng, map.getZoom());
            }
            
            // Redraw the custom layer and update the chart
            currentHeading = heading;
            // Defensive check before calling redraw
            if (headingSectorLayer && typeof headingSectorLayer.redraw === 'function') {
                console.log("Calling headingSectorLayer.redraw from updateAllUI."); // Debugging log
                // Pass no arguments as redraw now accesses global variables
                headingSectorLayer.redraw(); 
            } else {
                console.error("headingSectorLayer.redraw is not a function or headingSectorLayer is not defined.");
            }
            updateHeadingChart(currentHeading);
        }

        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
                setTimeout(() => messageBox.classList.add('hidden'), 500);
            }, duration);
        }

        // --- SIMULATION AND DATA HANDLING ---
        function startSimulation() {
            console.log("startSimulation function called."); // Added log
            if (simulationInterval) clearInterval(simulationInterval);
            isSimulating = true;
            toggleSimBtn.textContent = isJapanese ? 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼åœæ­¢' : 'Stop Simulator';
            toggleSimBtn.classList.remove('bg-yellow-400');
            toggleSimBtn.classList.add('bg-gray-400');
            showMessage(isJapanese ? "ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼èµ·å‹•ã—ã¾ã—ãŸã€‚" : "Simulator started.", 2000);

            const speed = 0.00001; // Movement speed
            let currentLat = currentPosition[0];
            let currentLng = currentPosition[1];
            let currentAlt = currentPosition[2]; // Use current altitude
            let currentHdg = currentHeading;

            simulationInterval = setInterval(() => {
                console.log("Simulating and updating UI inside setInterval..."); // Debugging log inside interval
                // Simulate movement
                currentHdg = (currentHdg + (Math.random() - 0.5) * 5) % 360;
                currentLat += Math.cos(currentHdg * Math.PI / 180) * speed;
                currentLng += Math.sin(currentHdg * Math.PI / 180) * speed;
                currentAlt += (Math.random() - 0.5) * 5; // Simulate more significant altitude change for testing elevation angle

                // Clamp lat/lng
                currentLat = Math.max(-90, Math.min(90, currentLat));
                currentLng = Math.max(-180, Math.min(180, currentLng));

                updateAllUI(currentLat, currentLng, currentHdg, currentAlt); // Pass altitude
                // currentPosition is already updated inside updateAllUI
                logData.push({
                    timestamp: new Date().toISOString(),
                    lat: currentLat,
                    lng: currentLng,
                    heading: currentHdg,
                    alt: currentAlt, // Log altitude
                    status: 'RTK-FIX'
                });
            }, 500);
        }

        function stopSimulation() {
            console.log("stopSimulation function called."); // Added log
            isSimulating = false;
            clearInterval(simulationInterval);
            toggleSimBtn.textContent = isJapanese ? 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼èµ·å‹•' : 'Start Simulator';
            toggleSimBtn.classList.remove('bg-gray-400');
            toggleSimBtn.classList.add('bg-yellow-400');
            showMessage(isJapanese ? "ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼åœæ­¢ã—ã¾ã—ãŸã€‚" : "Simulator stopped.", 2000);
        }

        // CSV Playback
        function playCsvData(data) {
            let index = 0;
            const interval = setInterval(() => {
                console.log("Playing CSV data and updating UI..."); // Debugging log
                if (index < data.length) {
                    const row = data[index];
                    // Ensure altitude is read from CSV if available, otherwise default to 0
                    const alt = parseFloat(row.alt) || 0; 
                    updateAllUI(parseFloat(row.lat), parseFloat(row.lng), parseFloat(row.heading), alt);
                    gpsStatusSpan.textContent = row.status;
                    gpsStatusSpan.style.color = 'green';
                    
                    // currentPosition is already updated inside updateAllUI
                    index++;
                } else {
                    clearInterval(interval);
                    showMessage(isJapanese ? "CSVå†ç”ŸãŒå®Œäº†ã—ã¾ã—ãŸã€‚" : "CSV playback complete.", 3000);
                }
            }, 500); 
        }

        // --- Event Listeners and Handlers ---

        // Toggle simulation
        toggleSimBtn.addEventListener('click', () => {
            if (isSimulating) {
                stopSimulation();
            } else {
                startSimulation();
            }
        });

        // Toggle language
        toggleLangBtn.addEventListener('click', () => {
            isJapanese = !isJapanese;
            const elements = document.querySelectorAll('[data-label-ja], [data-label-en]');
            elements.forEach(el => {
                if (isJapanese) {
                    el.textContent = el.dataset.labelJa;
                } else {
                    el.textContent = el.dataset.labelEn;
                }
            });
            // Update button texts and messages
            toggleSimBtn.textContent = isSimulating ? (isJapanese ? 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼åœæ­¢' : 'Stop Simulator') : (isJapanese ? 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼èµ·å‹•' : 'Start Simulator');
            toggleFollowBtn.textContent = isFollowing ? (isJapanese ? 'è¿½å¾“: ON' : 'Follow: ON') : (isJapanese ? 'è¿½å¾“: OFF' : 'Follow: OFF');
            centerMapBtn.textContent = isJapanese ? 'è‡ªå·±ä½ç½®ã«ç§»å‹•' : 'Center Map';
            downloadLogBtn.textContent = isJapanese ? 'ãƒ­ã‚°ä¿å­˜' : 'Download Log';
            clearRouteBtn.textContent = isJapanese ? 'ãƒ«ãƒ¼ãƒˆã‚¯ãƒªã‚¢' : 'Clear Route';
            toggleDebugBtn.textContent = isDebugging ? 'Debug: ON' : 'Debug: OFF'; // Debug text remains English
            servoBtn.textContent = isJapanese ? 'ã‚µãƒ¼ãƒœåˆ¶å¾¡ï¼ˆä»®æƒ³ï¼‰' : 'Servo Control (Virtual)';
            clearCacheBtn.textContent = isJapanese ? 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢' : 'Clear Cache';
            clearSymbolBtn.textContent = isJapanese ? 'ã‚·ãƒ³ãƒœãƒ«ã‚¯ãƒªã‚¢' : 'Clear Symbols';
            document.querySelector('label[for="csvUpload"]').textContent = isJapanese ? 'CSVå†ç”Ÿ' : 'Play CSV';
            document.querySelector('#controlPanel h2').textContent = isJapanese ? 'åˆ¶å¾¡ãƒ»ã‚°ãƒ©ãƒ•' : 'Control & Charts';
            document.querySelector('#controlPanel h3').textContent = isJapanese ? 'æ–¹ä½è§’ã®åˆ†å¸ƒ' : 'Heading Distribution';
            document.querySelector('label[for="frequencyInput"]').textContent = isJapanese ? 'å‘¨æ³¢æ•°' : 'Frequency'; // New: Language for frequency label
            
            // Update the chart label
            if (headingChart) {
                headingChart.data.datasets[0].label = isJapanese ? 'æ–¹ä½è§’ã®åˆ†å¸ƒ' : 'Heading Distribution';
                headingChart.update();
            }

            showMessage(isJapanese ? "è¨€èªã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚" : "Language switched.", 1500);
        });

        // Center map
        centerMapBtn.addEventListener('click', () => {
            map.setView([currentPosition[0], currentPosition[1]], map.getZoom());
            showMessage(isJapanese ? "åœ°å›³ã‚’è‡ªå·±ä½ç½®ã«ç§»å‹•ã—ã¾ã—ãŸã€‚" : "Map centered on self-position.", 2000);
        });

        // Download log
        downloadLogBtn.addEventListener('click', () => {
            if (logData.length === 0) {
                showMessage(isJapanese ? "ä¿å­˜ã™ã‚‹ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚" : "No log data to save.", 2000);
                return;
            }
            const csvHeader = "timestamp,lat,lng,heading,alt,status\n";
            const csvRows = logData.map(row => 
                `${row.timestamp},${row.lat.toFixed(6)},${row.lng.toFixed(6)},${row.heading.toFixed(2)},${row.alt.toFixed(2)},${row.status}`
            ).join('\n');
            const csvContent = csvHeader + csvRows;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `gnss_log_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage(isJapanese ? "ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚" : "Log data saved.", 2000);
        });

        // Clear route
        clearRouteBtn.addEventListener('click', () => {
            routeCoordinates = [];
            routePolyline.setLatLngs(routeCoordinates);
            showMessage(isJapanese ? "ãƒ«ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚" : "Route cleared.", 2000);
        });

        // CSV Upload
        csvUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                if (lines.length < 2) {
                    showMessage(isJapanese ? "ç„¡åŠ¹ãªCSVãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ãƒ˜ãƒƒãƒ€ãƒ¼ã¨ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ã€‚" : "Invalid CSV file. Header and data required.", 3000);
                    return;
                }
                const headers = lines[0].split(',').map(h => h.trim());
                const csvData = lines.slice(1).map(line => {
                    const values = line.split(',').map(v => v.trim());
                    let row = {};
                    headers.forEach((header, i) => {
                        row[header] = values[i];
                    });
                    return row;
                });
                playCsvData(csvData);
                showMessage(isJapanese ? `CSVãƒ•ã‚¡ã‚¤ãƒ« '${file.name}' ã‚’å†ç”Ÿã—ã¾ã™ã€‚` : `Playing CSV file '${file.name}'.`, 3000);
            };
            reader.onerror = () => {
                showMessage(isJapanese ? "CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚" : "Error reading CSV file.", 3000);
            };
            reader.readAsText(file); // This line was missing!
        });


        // Toggle debug state
        toggleDebugBtn.addEventListener('click', () => {
            console.log("Toggle Debug button clicked."); // Added log
            isDebugging = !isDebugging;
            if (isDebugging) {
                toggleDebugBtn.textContent = 'Debug: ON';
                gpsStatusSpan.textContent = 'DEBUG-ON';
                gpsStatusSpan.style.color = 'orange';
            } else {
                toggleDebugBtn.textContent = 'Debug: OFF';
                gpsStatusSpan.textContent = 'RTK-FIX';
                gpsStatusSpan.style.color = 'green';
            }
        });

        // Handle servo button (virtual)
        servoBtn.addEventListener('click', () => {
            console.log("Servo button clicked."); // Added log
            showMessage(isJapanese ? "ä»®æƒ³ã‚µãƒ¼ãƒœåˆ¶å¾¡ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚" : "Sent virtual servo control command.", 2000);
        });

        // Handle range input for sector angle
        sectorAngleInput.addEventListener('input', () => {
            console.log("Sector Angle input changed."); // Added log
            angleValSpan.textContent = sectorAngleInput.value;
            // Defensive check before calling redraw
            if (headingSectorLayer && typeof headingSectorLayer.redraw === 'function') {
                console.log("Calling headingSectorLayer.redraw on angle change."); // Debugging log
                headingSectorLayer.redraw(); // No arguments needed now
            } else {
                console.error("headingSectorLayer.redraw is not a function or headingSectorLayer is not defined on angle change.");
            }
        });

        // Handle frequency input change
        frequencyInput.addEventListener('input', () => {
            console.log("Frequency input changed.");
            updateSymbolInfoUI(); // Recalculate and update FSPL when frequency changes
        });


        // Handle offline tiles checkbox
        useOfflineTilesCheckbox.addEventListener('change', () => {
            console.log("Offline Tiles checkbox changed."); // Added log
            setTileLayer(useOfflineTilesCheckbox.checked); // Reinitialize layers when cache option changes
            showMessage(useOfflineTilesCheckbox.checked ? (isJapanese ? "ã‚¿ã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸã€‚" : "Tile caching enabled.") : (isJapanese ? "ã‚¿ã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸã€‚" : "Tile caching disabled."), 2000);
        });

        // Handle clear cache button
        clearCacheBtn.addEventListener('click', () => {
            console.log("Clear Cache button clicked."); // Added log
            // Clear only tiles associated with our cacheKey
            for (let i = localStorage.length - 1; i >= 0; i--) { // Iterate backwards to avoid issues with changing length
                const key = localStorage.key(i);
                if (key.startsWith('osm-tiles-')) {
                    localStorage.removeItem(key);
                }
            }
            setTileLayer(useOfflineTilesCheckbox.checked); // Reload tiles from scratch
            showMessage(isJapanese ? "ã‚¿ã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚" : "Tile cache cleared.", 2000);
        });

        // Handle map click to add a new symbol
        map.on('click', (e) => {
            console.log("Map clicked to add symbol."); // Added log
            const clickedLat = e.latlng.lat;
            const clickedLng = e.latlng.lng;
            // For simplicity, assume symbol altitude is same as current GPS altitude for now
            // In a real scenario, you'd fetch this from a DEM or user input
            const clickedAlt = currentPosition[2]; 

            const newMarker = L.marker([clickedLat, clickedLng], { draggable: true }).addTo(map);
            const newSymbolObj = { marker: newMarker, latLngAlt: [clickedLat, clickedLng, clickedAlt] };
            symbolMarkers.push(newSymbolObj); // Add new marker object to the array
            
            // Add dragend listener to the new marker
            newMarker.on('dragend', (dragEvent) => {
                console.log("Symbol marker dragged."); // Added log
                const draggedLatLng = dragEvent.target.getLatLng();
                // Find the symbol object in the array and update its latLngAlt
                const draggedSymbolIndex = symbolMarkers.findIndex(s => s.marker === dragEvent.target);
                if (draggedSymbolIndex !== -1) {
                    // Update the altitude of the dragged symbol to current GPS altitude for simplicity
                    symbolMarkers[draggedSymbolIndex].latLngAlt = [draggedLatLng.lat, draggedLatLng.lng, currentPosition[2]];
                }
                updateAllUI(currentPosition[0], currentPosition[1], currentHeading, currentPosition[2]); // Update UI
                showMessage(isJapanese ? "ã‚·ãƒ³ãƒœãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•ã—ã¾ã—ãŸã€‚" : "Symbol dragged and moved.", 2000);
            });

            // Update all symbol info immediately after adding a new one
            updateAllUI(currentPosition[0], currentPosition[1], currentHeading, currentPosition[2]);

            showMessage(isJapanese ? "ã‚·ãƒ³ãƒœãƒ«ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚" : "Symbol added.", 2000);
        });

        // Handle map right-click to set self-position
        map.on('contextmenu', (e) => {
            console.log("Map right-clicked to set self-position."); // Added log
            const newLat = e.latlng.lat;
            const newLng = e.latlng.lng;
            const currentAlt = currentPosition[2]; // Keep current altitude

            // Stop simulation if running
            if (isSimulating) {
                stopSimulation();
            }

            // Clear the existing route
            clearRouteBtn.click();

            // Update self-position and UI
            currentPosition = [newLat, newLng, currentAlt]; // Directly update currentPosition
            updateAllUI(newLat, newLng, currentHeading, currentAlt);
            showMessage(isJapanese ? `è‡ªå·±ä½ç½®ã‚’ ${newLat.toFixed(6)}, ${newLng.toFixed(6)} ã«ç§»å‹•ã—ã¾ã—ãŸã€‚` : `Self-position moved to ${newLat.toFixed(6)}, ${newLng.toFixed(6)}.`, 3000);
        });

        // Handle clear symbol button
        clearSymbolBtn.addEventListener('click', () => {
            console.log("Clear Symbol button clicked."); // Added log
            if (symbolMarkers.length > 0) {
                symbolMarkers.forEach(symbolObj => {
                    map.removeLayer(symbolObj.marker); // Remove each marker from the map
                });
                symbolMarkers = []; // Clear the array
                updateSymbolInfoUI(); // Clear the UI display
                // Explicitly redraw the HeadingSectorLayer to remove lines
                if (headingSectorLayer && typeof headingSectorLayer.redraw === 'function') {
                    headingSectorLayer.redraw(); 
                }
                showMessage(isJapanese ? "ã™ã¹ã¦ã®ã‚·ãƒ³ãƒœãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚" : "All symbols cleared.", 2000);
            } else {
                showMessage(isJapanese ? "ã‚¯ãƒªã‚¢ã™ã‚‹ã‚·ãƒ³ãƒœãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚" : "No symbols to clear.", 2000);
            }
        });

        // Toggle follow mode
        toggleFollowBtn.addEventListener('click', () => {
            console.log("Toggle Follow button clicked."); // Added log
            isFollowing = !isFollowing;
            if (isFollowing) {
                toggleFollowBtn.textContent = isJapanese ? 'è¿½å¾“: ON' : 'Follow: ON';
                toggleFollowBtn.classList.remove('bg-gray-200');
                toggleFollowBtn.classList.add('bg-blue-400');
                map.setView([currentPosition[0], currentPosition[1]], map.getZoom()); // Center immediately
            } else {
                toggleFollowBtn.textContent = isJapanese ? 'è¿½å¾“: OFF' : 'Follow: OFF';
                toggleFollowBtn.classList.remove('bg-blue-400');
                toggleFollowBtn.classList.add('bg-gray-200');
            }
        });

        // Tab switching logic
        tabMap.addEventListener('click', () => {
            mapPanel.classList.remove('hidden');
            controlPanel.classList.add('hidden');
            tabMap.classList.add('active', 'bg-blue-500', 'text-white');
            tabMap.classList.remove('bg-gray-200', 'text-gray-800');
            tabControl.classList.remove('active', 'bg-blue-500', 'text-white');
            tabControl.classList.add('bg-gray-200', 'text-gray-800');
            map.invalidateSize(); // Invalidate map size when switching to map tab
        });

        tabControl.addEventListener('click', () => {
            mapPanel.classList.add('hidden');
            controlPanel.classList.remove('hidden');
            tabControl.classList.add('active', 'bg-blue-500', 'text-white');
            tabControl.classList.remove('bg-gray-200', 'text-gray-800');
            tabMap.classList.remove('active', 'bg-blue-500', 'text-white');
            tabMap.classList.add('bg-gray-200', 'text-gray-800');
            // No need to invalidate map size when switching *from* map tab
        });


        // Initial UI state setup
        gpsStatusSpan.textContent = 'RTK-FIX';
        gpsStatusSpan.style.color = 'green';
        
        // Initialize the heading chart
        initHeadingChart();

        // Initial tile layer setup based on checkbox state
        setTileLayer(useOfflineTilesCheckbox.checked);

        // Initial update of UI values after all setup is complete
        updateAllUI(currentPosition[0], currentPosition[1], currentHeading, currentPosition[2]);
    });
</script>
</html>
